#+TITLE: Deploy design


* Table of Contents                                                     :TOC:
 - [[#introduction][Introduction]]
 - [[#design-of-deploy][Design of `deploy']]
   - [[#configuration-language][Configuration `language']]
   - [[#intermediate-representation][Intermediate representation]]
   - [[#transactions][Transactions]]
   - [[#modules-][Modules ]]
   - [[#parallelism][Parallelism]]
   - [[#fine-grained-output][Fine grained output]]
 - [[#install-gnu-guix-ruby-git-and-deploy][Install GNU Guix, ruby, git and deploy]]
 - [[#setting-up-a-deployment-definition][Setting up a deployment definition]]
   - [[#server][Server]]

* Introduction

`deploy' is a deployment tool which operates in the same domain as
Chef, Puppet, Cfengine and Cfruby. I have used all. Actually, I
created Cfruby with David Powers many years ago, the start was
probably in 2005 and sloccount estimates 2.5 years of
development. Cfruby was more of a Cfengine clone that works without a
server and I have been using it to manage work environments, mail
servers and web servers, all those years. Cfruby is showing its
age. It has good ideas, but somehow it is (still) too complicated or
too simple (depending on how you look at it). Also I want it to run
faster and use parallelisation.

So, what do I want out of a deployment tool? First of all it has to
copy configuration files from a git repository to defined places on a
host. That, by far, is the most important idea (I thank Kent Skaar for
introducing me to Cfengine around 2000) and requires a place to store
files and a mapping to the destination.

Second, I like the idea of (overlapping) machine classes as introduced
by Cfengine. So you can say that hostname is part of the webserver
class and also runs ssh (the ssh-server class). The mapping and global
configuration will be in YAML (this time).

Third, we want to be able to list properties of a machine. This means
we have to have an intermediate representation. Something that Cfruby 
misses and GNU Guix has.

Fourth, we want fine grained output that can be configured. Cfruby
went some way here, but I did not use it much because it was not good
enough.

Fifth, we don't want a client/server environment like the others have.
I strongly believe in simple tools and a runner + git checkout should
reflect the state of each machine. The simple runner can be run via
ssh to create a client/server setup.

Sixth, the configuration has to be simple. Really simple. In Cfruby we
created a Cfengine-type language. The problem with that is that you
have to understand that DSL. I think the idea of combining YAML with
Ruby is the way forward. Guile S-EXP would be even better (perhaps),
but we can add that as a front-end later. The intermediate
representation should help there.

Seventh, configuration can happen in parallel to speed things up, but
I said that already.

Eight, transaction support. Every 'module' should complete completely,
or not. The machine state should be in before or after. Not in
between. Ah yes, the concept of modules is there too.

`deploy' will be part of the GNU Guix setup. So install Guix and you
should be set to run this system. With a simple:

: deploy git://mygitserver/myenvironment.git

Will anyone use this? I don't know. The point is that it saves me a
lot of time to have this type of functionality on the systems I
manage. Sometimes (indeed) it is easier to write your own software.

* Design of `deploy'

** Configuration `language'

Configuration will be a compination of YAML and simple Ruby and/or
Guile. Depending on needs and preferences. You can write deploy
definitions with YAML and Ruby, YAML and Guile, or all three.

** Intermediate representation

An intermediate representation of actions allows us to create
views on that data. Also, for rolling back and deciding on 
parallel execution, the intermediate representation comes in
handy.

** Transactions

Transactions are surprisingly hard to achieve. The idea is to have
either the start or end state, but not what happens in between.  Think
of what happens during an install when electricity fails.

GNU Guix (and its sibling Nix) have the right idea: Create a new
directory for files and symlink to that in the final step. Nothing is
visible until the symlink changes. Rolling back is simply replacing a
symlink.

We will use GNU Guix for some stuff. So that is tactic one. 

Tactic two is to use the same symlink idea, but to implement it
ourselves.

Tactic three is to use git and roll-back on git.

Tactic four is to capture error conditions and roll back.

Just as an example, I use stunnel which has a configuration file
in /etc/stunnel/. With GNU Guix that file would be encoded and
hosted inside the stunnel store path. Rather clean! 

If we were to use a symlink, we'll symlink from
/etc/deploy/stunnel/stunnel-1, that would work too.

With git it is harder. The information about backtracking would be
contained in /etc/.git and manually restored.

With capturing error conditions we can maintain information in RAM and
write back the originals if the transaction does not complete.  Main
problem is for disruptions to a running install, i.e., what happens in
case of electricity failure?

** Modules 

A module is an independent entity. For example configuring vim
is independent of configuring emacs. A module is also a transaction.

We should be able to specify what modules to run or skip. For example
a directory cleaning module could normally be skipped.

** Parallelism

Independent modules can be executed in parallel because modules are
transactions.

** Fine grained output

Output should be fine grained and easy to control. Too much output
and people stop reading them. 

* Install GNU Guix, ruby, git and deploy

Note: GNU Guix is optional for running `deploy'. But if you want sane
and reproducible system installation, GNU Guix is the way to go. Also,
we will (sometimes) use GNU Guix for deployment itself. GNU Guix
shines where it comes to transactions, for example.

Follow the tar installation instruction on the Guix
website. Basically, download the tarball, unpack it, copy the relevant
dirs to /gnu and /var/gnu, add the relevant groups and users, and
start the Guix daemon.

Once Guix is running update Guix

: guix pull

and now we need guix, guile, ruby and git to run deploy

: guix package -i guix guile ruby git 

and set the path:

:  export PATH="/root/.guix-profile/bin:/root/.guix-profile/sbin"
:  export GEM_PATH="/root/.guix-profile/lib/ruby/gems/2.2.0"

Note that if you deploy these tools to multiple freshly installed
servers it may be worth using the guix archive functions to speed
things up, or even create your own tarball of guix (make sure to
include the database in /var).

To install deploy (for now) we checkout the git repo itself.

: git clone git://github.com/pjotrp/deploy.git

And you should be able to run

: ./deploy/bin/deploy

* Setting up a deployment definition

The first step is to set up a git repository to store the
definition. Here we are going to set up two examples, one for a server
installation and one for a HOME directory. Unsurprisingly 
I use both.

** Server

First the server. In the fresh git repo we add a YAML file named
'machines.yaml' that defines the host and the classes it belongs
to. E.g.

#+BEGIN_EXAMPLE
classes:
  - any:
    - ssh
    - guix
myhost01:
  - webserver
#+END_EXAMPLE

Where myhost01 is a hostname or group of hosts.

With Cfruby and cfengine classes were defined differently, but I like
this approach because it clearly lists what a machine should be doing.
Note: classes can be higher level abstractions and the host can also
be 'any' so this git repository definition is relevant to all
machines. So you can also write

#+BEGIN_EXAMPLE
groups:
  webservers:
    - myhost01
classes:
  - any:
    - ssh
    - guix
  - webservers:
    - webserver
#+END_EXAMPLE


To run this file simply point to the base directory or git repo, i.e.

: deploy run serverrepo

which will pick up the machines.yaml filedash from ./serverrepo/ dir.



